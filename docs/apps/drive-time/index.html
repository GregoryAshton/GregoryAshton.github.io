<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Drive Time Analyzer</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#f97316">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Drive Time">
<link rel="apple-touch-icon" href="icon-192.png">
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;600;700&display=swap');

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    min-height: 100vh;
    background: #0a0a1a;
    color: #e0e0e0;
    font-family: 'IBM Plex Mono', monospace;
    padding: 24px 16px;
    -webkit-text-size-adjust: 100%;
  }

  .container { max-width: 720px; margin: 0 auto; }

  .header { margin-bottom: 28px; }
  .header-row { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; }
  .dot {
    width: 10px; height: 10px; border-radius: 50%;
    background: #f97316; box-shadow: 0 0 12px #f9731688;
    flex-shrink: 0;
  }
  h1 {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 20px; font-weight: 700; letter-spacing: -0.5px;
  }
  .subtitle { color: #666; font-size: 12px; padding-left: 20px; }

  .card {
    background: #12122a; border: 1px solid #2a2a4a;
    border-radius: 12px; padding: 20px; margin-bottom: 20px;
  }

  label {
    display: block; font-size: 11px; color: #888;
    text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px;
  }

  input[type="text"], input[type="password"], input[type="time"], input[type="number"], select {
    width: 100%; padding: 12px 14px;
    background: #0f0f23; border: 1px solid #2a2a4a;
    border-radius: 8px; color: #e0e0e0; font-size: 15px;
    outline: none; font-family: 'IBM Plex Mono', monospace;
    -webkit-appearance: none;
  }
  select { -webkit-appearance: none; appearance: none; }
  input:focus, select:focus { border-color: #f9731666; }

  .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
  .row3 .field { margin-bottom: 0; }

  .key-row { display: flex; gap: 8px; }
  .key-row input { flex: 1; }

  .btn {
    padding: 12px 20px; border: none; border-radius: 8px;
    font-weight: 700; cursor: pointer;
    font-family: 'IBM Plex Mono', monospace; font-size: 14px;
    -webkit-appearance: none;
  }
  .btn-primary {
    background: #f97316; color: #000;
  }
  .btn-primary:disabled {
    background: #333; color: #888; cursor: not-allowed;
  }
  .btn-go {
    width: 100%; padding: 14px; font-size: 15px;
    background: linear-gradient(135deg, #f97316, #ea580c);
    color: #000; margin-top: 12px; letter-spacing: 0.5px;
  }
  .btn-go:disabled {
    background: #333; color: #888; cursor: not-allowed;
  }

  .hint { margin-top: 8px; color: #555; font-size: 11px; line-height: 1.5; }

  .field { margin-bottom: 14px; }

  .days {
    display: flex; gap: 5px; flex-wrap: wrap; margin-top: 6px;
  }
  .day-btn {
    padding: 8px 12px; background: #0f0f23; color: #888;
    border: 1px solid #2a2a4a; border-radius: 6px;
    cursor: pointer; font-size: 12px; font-weight: 400;
    font-family: 'IBM Plex Mono', monospace;
    -webkit-appearance: none;
  }
  .day-btn.active {
    background: #f97316; color: #000;
    border-color: #f97316; font-weight: 700;
  }

  .progress-bar {
    width: 100%; background: #1a1a2e; border-radius: 6px;
    height: 8px; overflow: hidden; margin-top: 10px;
  }
  .progress-fill {
    height: 100%; background: linear-gradient(90deg, #f97316, #fb923c);
    border-radius: 6px; transition: width 0.2s ease;
  }

  .error {
    margin-top: 12px; padding: 10px 14px;
    background: #2a0a0a; border: 1px solid #6b2020;
    border-radius: 8px; color: #f87171; font-size: 13px;
  }

  .stats {
    display: grid; grid-template-columns: 1fr 1fr 1fr;
    gap: 10px; margin-bottom: 20px;
  }
  .stat-card {
    background: #12122a; border: 1px solid #2a2a4a;
    border-radius: 12px; padding: 14px;
  }
  .stat-label {
    font-size: 10px; color: #666;
    text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;
  }
  .stat-value { font-size: 18px; font-weight: 700; }
  .stat-sub { font-size: 12px; color: #888; margin-top: 2px; }
  .green { color: #4ade80; }
  .red { color: #f87171; }
  .orange { color: #f97316; }

  .chart-card {
    background: #12122a; border: 1px solid #2a2a4a;
    border-radius: 12px; padding: 16px; margin-bottom: 16px;
  }
  .chart-title {
    font-family: 'Space Grotesk', sans-serif;
    font-size: 14px; font-weight: 600; color: #ccc;
    margin-bottom: 12px;
  }
  canvas { width: 100% !important; }

  .footnote {
    color: #444; font-size: 10px; text-align: center;
    margin-top: 12px; line-height: 1.5;
  }

  .hidden { display: none; }
</style>
</head>
<body>

<div class="container">
  <div class="header">
    <div class="header-row">
      <div class="dot"></div>
      <h1>Drive Time Analyzer</h1>
    </div>
    <p class="subtitle">See how traffic affects your drive throughout the day</p>
  </div>

  <!-- API Key Section -->
  <div class="card" id="keySection">
    <label>Google Maps API Key</label>
    <div class="key-row">
      <input type="password" id="apiKeyInput" placeholder="AIza...">
      <button class="btn btn-primary" id="connectBtn" onclick="connectApi()">Connect</button>
    </div>
    <p class="hint">
      Needs Maps JavaScript API + Directions API enabled.<br>
      Key stays in your browser â€” nothing sent anywhere else.
    </p>
    <div id="keyError"></div>
  </div>

  <!-- Main Form -->
  <div class="card hidden" id="formSection">
    <div class="field">
      <label>Origin</label>
      <input type="text" id="originInput" placeholder="e.g. Haslemere, UK">
    </div>
    <div class="field">
      <label>Destination</label>
      <input type="text" id="destInput" placeholder="e.g. London, UK">
    </div>
    <div class="field">
      <label>Day of Week</label>
      <div class="days" id="dayButtons"></div>
    </div>
    <div class="field" style="margin-top: 14px;">
      <div class="row3">
        <div class="field">
          <label>Start Time</label>
          <input type="time" id="startTime" value="07:00">
        </div>
        <div class="field">
          <label>End Time</label>
          <input type="time" id="endTime" value="19:00">
        </div>
        <div class="field">
          <label>Sample (min)</label>
          <input type="number" id="sampleRate" value="5" min="1" max="60" step="1">
        </div>
      </div>
    </div>
    <button class="btn btn-go" id="analyzeBtn" onclick="analyze()">Analyze Drive Times</button>
    <div id="progressContainer" class="hidden" style="margin-top: 12px;">
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <p style="color: #888; font-size: 12px; margin-top: 6px;" id="progressText"></p>
    </div>
    <div id="formError"></div>
  </div>

  <!-- Results -->
  <div id="resultsSection" class="hidden">
    <div class="stats" id="statsGrid"></div>
    <div class="chart-card">
      <div class="chart-title" id="chartTitle"></div>
      <canvas id="chart" height="220"></canvas>
    </div>
    <p class="footnote" id="footnote"></p>
  </div>
</div>

<script>
const DAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
let selectedDay = 1; // Monday

// Build day buttons
const dayContainer = document.getElementById('dayButtons');
DAYS.forEach((d, i) => {
  const btn = document.createElement('button');
  btn.className = 'day-btn' + (i === selectedDay ? ' active' : '');
  btn.textContent = d.slice(0, 3);
  btn.onclick = () => {
    selectedDay = i;
    document.querySelectorAll('.day-btn').forEach((b, j) => {
      b.className = 'day-btn' + (j === i ? ' active' : '');
    });
  };
  dayContainer.appendChild(btn);
});

function connectApi() {
  const key = document.getElementById('apiKeyInput').value.trim();
  if (!key) return;

  const btn = document.getElementById('connectBtn');
  btn.disabled = true;
  btn.textContent = 'Loading...';
  document.getElementById('keyError').innerHTML = '';

  window.gm_authFailure = () => {
    btn.disabled = false;
    btn.textContent = 'Connect';
    document.getElementById('keyError').innerHTML =
      '<div class="error">Authentication failed. Check your API key and ensure Maps JavaScript API + Directions API are enabled.</div>';
  };

  const cbName = '_gmcb_' + Date.now();
  window[cbName] = () => {
    delete window[cbName];
    document.getElementById('keySection').classList.add('hidden');
    document.getElementById('formSection').classList.remove('hidden');
  };

  const s = document.createElement('script');
  s.src = 'https://maps.googleapis.com/maps/api/js?key=' + key + '&callback=' + cbName;
  s.async = true;
  s.onerror = () => {
    btn.disabled = false;
    btn.textContent = 'Connect';
    document.getElementById('keyError').innerHTML =
      '<div class="error">Failed to load Google Maps. Check your API key.</div>';
    delete window[cbName];
  };
  document.head.appendChild(s);
}

function getNextDay(dayIdx) {
  const now = new Date();
  let diff = dayIdx - now.getDay();
  if (diff <= 0) diff += 7;
  const d = new Date(now);
  d.setDate(now.getDate() + diff);
  d.setHours(0, 0, 0, 0);
  return d;
}

function fmtMin(m) {
  if (m < 60) return Math.round(m) + ' min';
  const h = Math.floor(m / 60);
  const r = Math.round(m % 60);
  return r > 0 ? h + 'h ' + r + 'm' : h + 'h';
}

async function analyze() {
  const origin = document.getElementById('originInput').value.trim();
  const dest = document.getElementById('destInput').value.trim();
  if (!origin || !dest) {
    document.getElementById('formError').innerHTML = '<div class="error">Please enter both locations.</div>';
    return;
  }
  document.getElementById('formError').innerHTML = '';

  const btn = document.getElementById('analyzeBtn');
  btn.disabled = true;
  document.getElementById('progressContainer').classList.remove('hidden');
  document.getElementById('resultsSection').classList.add('hidden');

  const service = new google.maps.DirectionsService();
  const baseDate = getNextDay(selectedDay);

  // Parse time inputs
  const startParts = document.getElementById('startTime').value.split(':');
  const endParts = document.getElementById('endTime').value.split(':');
  const startMinTotal = parseInt(startParts[0]) * 60 + parseInt(startParts[1]);
  const endMinTotal = parseInt(endParts[0]) * 60 + parseInt(endParts[1]);
  const interval = Math.max(1, parseInt(document.getElementById('sampleRate').value) || 5);

  if (endMinTotal <= startMinTotal) {
    document.getElementById('formError').innerHTML = '<div class="error">End time must be after start time.</div>';
    btn.disabled = false;
    return;
  }

  const slots = [];
  for (let t = startMinTotal; t <= endMinTotal; t += interval) {
    slots.push({ hour: Math.floor(t / 60), minute: t % 60 });
  }

  // Run both directions
  const directions = [
    { origin: origin, destination: dest, label: 'outbound' },
    { origin: dest, destination: origin, label: 'return' }
  ];
  const total = slots.length * 2;
  let doneCount = 0;
  const allData = { outbound: [], return: [] };
  const BATCH = 4;

  for (const dir of directions) {
    for (let i = 0; i < slots.length; i += BATCH) {
      const batch = slots.slice(i, i + BATCH);
      const results = await Promise.all(batch.map(slot => new Promise(resolve => {
        const dt = new Date(baseDate);
        dt.setHours(slot.hour, slot.minute, 0, 0);
        service.route({
          origin: dir.origin, destination: dir.destination,
          travelMode: 'DRIVING',
          drivingOptions: { departureTime: dt, trafficModel: 'bestguess' }
        }, (res, status) => {
          if (status === 'OK' && res.routes[0]) {
            const leg = res.routes[0].legs[0];
            const dur = (leg.duration_in_traffic || leg.duration).value / 60;
            const base = leg.duration.value / 60;
            resolve({
              hour: slot.hour, minute: slot.minute,
              time: String(slot.hour).padStart(2,'0') + ':' + String(slot.minute).padStart(2,'0'),
              duration: Math.round(dur * 10) / 10,
              baseline: Math.round(base * 10) / 10,
              ratio: dur / base
            });
          } else { resolve(null); }
        });
      })));

      results.forEach(r => r && allData[dir.label].push(r));
      doneCount += batch.length;
      document.getElementById('progressFill').style.width = ((doneCount / total) * 100) + '%';
      document.getElementById('progressText').textContent = doneCount + ' / ' + total + ' time slots checked';
      btn.textContent = 'Analyzing... (' + doneCount + '/' + total + ')';

      if (i + BATCH < slots.length) await new Promise(r => setTimeout(r, 300));
    }
  }

  allData.outbound.sort((a, b) => (a.hour * 60 + a.minute) - (b.hour * 60 + b.minute));
  allData.return.sort((a, b) => (a.hour * 60 + a.minute) - (b.hour * 60 + b.minute));

  btn.disabled = false;
  btn.textContent = 'Analyze Drive Times';
  document.getElementById('progressContainer').classList.add('hidden');

  if (allData.outbound.length === 0 && allData.return.length === 0) {
    document.getElementById('formError').innerHTML = '<div class="error">No results returned. Check that the locations are valid driving routes.</div>';
    return;
  }

  showResults(allData);
}

function showResults(allData) {
  const ob = allData.outbound;
  const rt = allData.return;
  const bestOb = ob.reduce((a, b) => a.duration < b.duration ? a : b);
  const worstOb = ob.reduce((a, b) => a.duration > b.duration ? a : b);
  const bestRt = rt.reduce((a, b) => a.duration < b.duration ? a : b);
  const worstRt = rt.reduce((a, b) => a.duration > b.duration ? a : b);

  document.getElementById('statsGrid').innerHTML =
    '<div class="stat-card"><div class="stat-label">Best Outbound</div><div class="stat-value green">' + bestOb.time + '</div><div class="stat-sub">' + fmtMin(bestOb.duration) + '</div></div>' +
    '<div class="stat-card"><div class="stat-label">Worst Outbound</div><div class="stat-value red">' + worstOb.time + '</div><div class="stat-sub">' + fmtMin(worstOb.duration) + '</div></div>' +
    '<div class="stat-card"><div class="stat-label">Outbound Diff</div><div class="stat-value orange">' + fmtMin(worstOb.duration - bestOb.duration) + '</div><div class="stat-sub">potential saving</div></div>' +
    '<div class="stat-card"><div class="stat-label">Best Return</div><div class="stat-value" style="color:#38bdf8;">' + bestRt.time + '</div><div class="stat-sub">' + fmtMin(bestRt.duration) + '</div></div>' +
    '<div class="stat-card"><div class="stat-label">Worst Return</div><div class="stat-value red">' + worstRt.time + '</div><div class="stat-sub">' + fmtMin(worstRt.duration) + '</div></div>' +
    '<div class="stat-card"><div class="stat-label">Return Diff</div><div class="stat-value orange">' + fmtMin(worstRt.duration - bestRt.duration) + '</div><div class="stat-sub">potential saving</div></div>';

  const startStr = document.getElementById('startTime').value;
  const endStr = document.getElementById('endTime').value;
  const intervalVal = document.getElementById('sampleRate').value;

  document.getElementById('chartTitle').textContent = 'Drive time on ' + DAYS[selectedDay] + 's';
  document.getElementById('footnote').textContent =
    'Based on Google\'s typical traffic predictions for ' + DAYS[selectedDay] + 's. Sampled every ' + intervalVal + ' min from ' + startStr + ' to ' + endStr + '.';

  document.getElementById('resultsSection').classList.remove('hidden');
  drawChart(allData);
}

function drawChart(allData) {
  const ob = allData.outbound;
  const rt = allData.return;
  const canvas = document.getElementById('chart');
  const ctx = canvas.getContext('2d');

  // Hi-DPI support
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;

  const pad = { top: 28, right: 16, bottom: 36, left: 52 };
  const cw = W - pad.left - pad.right;
  const ch = H - pad.top - pad.bottom;

  const allDurations = ob.map(d => d.duration).concat(rt.map(d => d.duration));
  const minD = Math.floor(Math.min(...allDurations) / 5) * 5 - 5;
  const maxD = Math.ceil(Math.max(...allDurations) / 5) * 5 + 5;

  ctx.clearRect(0, 0, W, H);

  // Grid lines
  const yTicks = 5;
  ctx.strokeStyle = '#1a1a3a';
  ctx.lineWidth = 0.5;
  ctx.font = '10px "IBM Plex Mono", monospace';
  ctx.fillStyle = '#555';
  ctx.textAlign = 'right';

  for (let i = 0; i <= yTicks; i++) {
    const val = minD + (maxD - minD) * (i / yTicks);
    const y = pad.top + ch - (i / yTicks) * ch;
    ctx.beginPath();
    ctx.setLineDash([3, 3]);
    ctx.moveTo(pad.left, y);
    ctx.lineTo(W - pad.right, y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillText(fmtMin(val), pad.left - 8, y + 3);
  }

  // X labels (use outbound data for labels)
  const data = ob.length >= rt.length ? ob : rt;
  ctx.textAlign = 'center';
  ctx.fillStyle = '#555';
  const labelEvery = Math.max(1, Math.floor(data.length / 8));
  data.forEach((d, i) => {
    if (i % labelEvery === 0) {
      const x = pad.left + (i / (data.length - 1)) * cw;
      ctx.fillText(d.time, x, H - pad.bottom + 18);
    }
  });

  // Helper to draw a line with area fill
  function drawLine(series, color, colorFill) {
    if (series.length === 0) return;
    // Area fill
    ctx.beginPath();
    series.forEach((d, i) => {
      const x = pad.left + (i / (series.length - 1)) * cw;
      const y = pad.top + ch - ((d.duration - minD) / (maxD - minD)) * ch;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.lineTo(pad.left + cw, pad.top + ch);
    ctx.lineTo(pad.left, pad.top + ch);
    ctx.closePath();
    const grad = ctx.createLinearGradient(0, pad.top, 0, pad.top + ch);
    grad.addColorStop(0, colorFill);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fill();

    // Line
    ctx.beginPath();
    series.forEach((d, i) => {
      const x = pad.left + (i / (series.length - 1)) * cw;
      const y = pad.top + ch - ((d.duration - minD) / (maxD - minD)) * ch;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    ctx.lineJoin = 'round';
    ctx.setLineDash([]);
    ctx.stroke();
  }

  drawLine(ob, '#f97316', '#f9731618');
  drawLine(rt, '#38bdf8', '#38bdf818');

  // Best point markers
  function drawBest(series, color) {
    if (series.length === 0) return;
    const best = series.reduce((a, b) => a.duration < b.duration ? a : b);
    const idx = series.indexOf(best);
    const bx = pad.left + (idx / (series.length - 1)) * cw;
    const by = pad.top + ch - ((best.duration - minD) / (maxD - minD)) * ch;
    ctx.beginPath();
    ctx.arc(bx, by, 5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = '#0a0a1a';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  drawBest(ob, '#4ade80');
  drawBest(rt, '#4ade80');

  // Legend
  ctx.font = '11px "IBM Plex Mono", monospace';
  ctx.textAlign = 'left';
  const legendY = 12;
  const legendX = pad.left + 4;
  // Outbound
  ctx.fillStyle = '#f97316';
  ctx.fillRect(legendX, legendY - 4, 14, 3);
  ctx.fillStyle = '#aaa';
  ctx.fillText('Outbound', legendX + 20, legendY);
  // Return
  const retX = legendX + 100;
  ctx.fillStyle = '#38bdf8';
  ctx.fillRect(retX, legendY - 4, 14, 3);
  ctx.fillStyle = '#aaa';
  ctx.fillText('Return', retX + 20, legendY);
}

// Remember API key in localStorage so user doesn't re-enter each visit
try {
  const savedKey = localStorage.getItem('dt_apikey');
  if (savedKey) document.getElementById('apiKeyInput').value = savedKey;
} catch(e) {}

const _origConnect = connectApi;
connectApi = function() {
  try {
    const k = document.getElementById('apiKeyInput').value.trim();
    if (k) localStorage.setItem('dt_apikey', k);
  } catch(e) {}
  _origConnect();
};

// Register service worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}
</script>
</body>
</html>
